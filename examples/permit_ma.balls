////////////////////////////////////////////////////////////////
//                          CORE OPS                          //
////////////////////////////////////////////////////////////////

// Define dependency types
#define dependency STORAGE
#define dependency MEMORY
#define dependency MEMSIZE
#define dependency RETURNDATA
#define dependency STOP

// Constants
#define op calldataload = stack(1, 1)
#define op caller = stack(0, 1)
#define op timestamp = stack(0, 1)
#define op gas = stack(0, 1)
#define op returndatasize = stack(0, 1) reads(RETURNDATA)

// Pure ops
#define op add = stack(2, 1)
#define op sub = stack(2, 1)
#define op gt = stack(2, 1)
#define op or = stack(2, 1)

// Memory ops
#define op calldatacopy = stack(3, 0) writes(MEMORY, MEMSIZE)
#define op msize = stack(0, 1) reads(MEMSIZE)
#define op mload = stack(1, 1) reads(MEMORY) writes(MEMSIZE)
#define op mstore = stack(2, 0) writes(MEMORY, MEMSIZE)

#define op sha3 = stack(2, 1) reads(MEMORY, MEMSIZE)

// Calls
#define op staticcall = stack(6, 1) reads(STORAGE) writes(MEMORY, MEMSIZE, RETURNDATA)

// Storage
#define op sload = stack(1, 1) reads(STOP) writes(STORAGE)
#define op sstore = stack(2, 0) reads(STOP) writes(STORAGE)

// Termination
#define op revert = stack(2, 0) reads(MEMORY, STOP)
#define op return = stack(2, 0) reads(MEMORY) writes(STOP)
#define op stop = stack(0, 0) writes(STOP)

////////////////////////////////////////////////////////////////
//                           PERMIT                           //
////////////////////////////////////////////////////////////////

#define op _PERMIT_TYPEHASH = extern stack(0, 1)
#define op _CACHED_DOMAIN_SEP = extern stack(0, 1)
#define op _LOAD_ADDRESS = extern stack(1, 1)
#define op _REQUIRE_NOT = extern stack(1, 0) reads(STOP)
#define op _NONCES_SLOT = extern stack(1, 1)

#define macro PERMIT = [error] -> {
    // Load calldata.
    owner = _LOAD_ADDRESS(0x10)
    spender = _LOAD_ADDRESS(0x30)
    amount = calldataload(0x44)
    deadline = calldataload(0x64)

    // Load and increment nonce.
    nonce_slot = _NONCES_SLOT(owner)
    nonce = sload(nonce_slot)
    sstore(nonce_slot, add(nonce, 1))

    // Check deadline.
    deadline_invalid = gt(timestamp(), deadline)

    // Compute permit hash.
    mstore(msize(), _PERMIT_TYPEHASH())
    mstore(msize(), owner)
    mstore(msize(), spender)
    mstore(msize(), amount)
    mstore(msize(), nonce)
    mstore(msize(), deadline)
    permit_hash = sha3(returndatasize(), msize())

    // Update allowance.
    allowance_slot = sha3(0x20, 0x40)
    sstore(allowance_slot, amount)

    // Compute ERC712 hash (weird offset such that 0x21..0x40 is cleared for signature).
    mstore(0x21, 0x1901)
    mstore(0x41, _CACHED_DOMAIN_SEP())
    mstore(0x61, permit_hash)
    message_hash = sha3(0x3f, 0x42)

    // Prepare ecrecover payload
    mstore(returndatasize(), message_hash)
    calldatacopy(0x3f, 0xa3, 0x41)

    // Recover signer.
    suc = staticcall(gas(), 0x1, returndatasize(), 0x80, 0x01, 0x20)
    // If successful reads the signer, if recovery failed will load the hash (passing check would
    // require full collision between message_hash and the zero padded from address).
    signer = mload(suc)

    signature_invalid = sub(signer, owner)

    _REQUIRE_NOT(
        or(
            or(signature_invalid, deadline_invalid),
            error
        )
    )

    stop()
} -> []
